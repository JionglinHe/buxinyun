---
title: 运动DV项目开发文档 
tags: 杰理,运动DV,文档
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true

---



# 前言

本文档定义了杰理AC56行车记录仪/运动DV的SDK功能介绍以及开发说明等内容。
本文档最终解释权归珠海杰理科技股份有限公司。

# 修订记录



| 修订时间 | 修订版本 | 修订人 | 修订描述  |
| --------- | --------- | ---------|--------- |
| 2017/02/14 | V0.1 |  薛勇  |  初稿  |


# 目录

[TOC]


## 1 SDK结构说明

### 1.1 总体结构说明

| 目录 | 说明  |
| ----  |	----  |
| app  | 应用层相关文件存放目录 |
| camera |	摄像头驱动存放目录  |
|  cau | 测试文件，测试网络速率   |
| doc  |  软硬件开发文档存放目录   |
|  include_lib  |  库文件及其头文件存放目录   |
|  lib  | 存放外部生成库文件示例|

### 1.2 部分文件说明 

| 文件名  | 说明  |
| ----    | ----  |
|ap_config.c         | 用于配置wifi模块通道，加密方式等|
|ctp_cmd.c           | 实现与手机通信的命令   |
|iperf_test.c          | 测试文件，测试网络速率   |
|wifi_mp_test.c     | WIFI测试文件   |
|wifi_app_task.c   | wifi以及相关网络应用初始化  |
|video_playback.c |  APP网络回放  |
|video_preview.c   | APP获取缩略图和封面图  |
|video_rt_tcp.c      |  TCP实时流  |
|video_rt_udp.c     |  UDP实时流 |

注：板级配置文件位于cpu\AC54xx\board
	  下载目录位于cpu\AC54xx\tools
      屏幕驱动位于cpu\AC54xx\dvp_lcd_driver或者cpu\AC54xx\mipi_lcd_driver

## 2 DV16 API函数说明
### 2.1 gpio控制说明
```c
	  /*函数说明:设置IO口为输入
	  参数说明:所要控制IO，参数形如IO_PORTX_N
	  特别说明:IO_PORTX_N(第一个X是IO组别起始为A,第二个N是表示该组第几脚范围0-15)，例如 IO_PORTH_13*/
	   1、int gpio_direction_input(unsigned int gpio);
	   
	  /*	  函数说明:设置IO口为输出，并输出value值
	  参数说明:所要控制IO，value可选值0,1表示高低电平 */
	  2、int gpio_direction_output(unsigned int gpio, int value);
	  
	  /*函数说明:设置上拉
	  参数说明:所要控制IO，value可选值0,1，0表示关闭上拉，1表示打开*/
	 3、int gpio_set_pull_up(unsigned int gpio, int value);
	 
	 /* 函数说明:设置下拉
	  参数说明:所要控制IO，value可选值0,1，0表示关闭下拉，1表示打开*/
	4、int gpio_set_pull_down(unsigned int gpio, int value);

	 /* 函数说明:设置强驱
	  参数说明:所要控制IO，value可选值0,1，0表示关闭强驱，1表示打开*/
	5、int gpio_set_hd(unsigned int gpio, int value);
	
      /*函数说明:设置数字输入允许控制器
	  参数说明:所要控制IO，value可选值0,1，0表示关闭，1表示打开*/
	6、int gpio_set_die(unsigned int gpio, int value);
	
      /*函数说明:当io为输入时，可调用该函数读取IO口的电平，并返回电平值，选项有0、1
	  参数说明:所要读取IO*/
	7、int gpio_read(unsigned int gpio);

```
## 3 DV16相关配置说明

### 3.1 下载配置说明
1、由于54以及56芯片有所不同，需要修改两个文件ram.ld以及isd_tools_flash-new.cfg
54芯片配置：
ram.ld：
```c
SDRAM_SIZE = 64M;
__cpu_id__ = 54;
```
isd_tools_flash-new.cfg：
```c
#############################################
#************************************config 54 begin***********************************************
#############################################

###配置选项一==================================================================
##########################################DDR2需要打开该配置===================
sdram_colum = 1;               [9~10]The Column Address is specified byA0-9
sdram_size = 64M;
###============================================================================

###配置选项二==================================================================
###DDR2配置、默认选DDR2_800====================================================
##DDR2_500
#sdram_clk = 250MHz;			200-600M
#sdram_mode = DDR2;				[ddr2:ddr1]
#sdram_cl = 3;         			[3-7]
#sdram_wlcnt = 0;
#sdram_d_dly = 1;
#sdram_rlcnt = 3;
#sdram_q_dly = 1;
#sdram_phase = 0;


##DDR2_800
sdram_clk = 400MHz;			200-600M
sdram_mode = DDR2;				[ddr2:ddr1]
sdram_cl = 5;         			[3-7]
sdram_wlcnt = 1;
sdram_d_dly = 0;
sdram_rlcnt = 4;
sdram_q_dly = 0;
sdram_phase = 3;

##DDR2_1066
#sdram_clk = 500MHz;				200-600M
#sdram_mode = DDR2;				[ddr2:ddr1]
#sdram_cl = 7;         			[3-7]
#sdram_wlcnt = 2;
#sdram_d_dly = 0;
#sdram_rlcnt = 5;
#sdram_q_dly = 0;
#sdram_phase = 3;

#DDR universally timing configuration
sdram_trfc = 105;                Refresh Cycle Time Unit is ns[1-63]
sdram_trp = 16;                 Row Precharge time Unit is ns[1-15]
sdram_trcd = 16;                Row to Column Delay Unit is ns[1-15]
sdram_trrd = 10;                Act to Act Delay time Unit is ns[1-15]
sdram_trtw = 8;					0-15
sdram_twr  = 15;				0-15
sdram_twtr = 8;					0-15
sdram_trc  = 60;				0-15
###============================================================================

#############################################
#*************************************config 54 end******************************************
#############################################
```
56芯片配置：
ram.ld：
```c
SDRAM_SIZE = 32M;
__cpu_id__ = 56;
```
isd_tools_flash-new.cfg：
```c
#############################################
#***********************************config 56 begin*****************************************
#############################################
###配置选项三==================================================================
###ddr1配置====================================================================
#DDR1_400
#sdram_clk = 200MHz;			200-600M
#sdram_mode = DDR1;				[ddr2:ddr1]
#sdram_colum = 0;               [9~10]The Column Address is specified byA0-9
#sdram_size = 32M;
#sdram_cl = 3;         			[2-7]
#sdram_wlcnt = 0;
#sdram_d_dly = 1;
#sdram_rlcnt = 3;
#sdram_q_dly = 1;
#sdram_phase = 1;

#DDR universally timing configuration
#sdram_trfc = 70;                Refresh Cycle Time Unit is ns[1-63]
#sdram_trp = 15;                 Row Precharge time Unit is ns[1-15]
#sdram_trcd = 15;                Row to Column Delay Unit is ns[1-15]
#sdram_trrd = 10;               Act to Act Delay time Unit is ns[1-15]
#sdram_twtr = 16;				2个tck
#sdram_trtw = 16;				2个tck
#sdram_twr  = 15;				0-15
#sdram_trc  = 55;				0-15
###============================================================================

#############################################
#********************************config 56 end*****************************************
#############################################

注：isd_tools_flash-new.cfg中uart_io=PH10;可指定打开uboot打印，注释掉可关闭uboot打印

```

### 3.2  录像配置说明
#### 3.2.1  录像相关宏说明

```c
#define CONFIG_VIDEO0_ENABLE 		             /* 前摄像头使能      */
#define CONFIG_VIDEO1_ENABLE 		            /* 模拟后摄像头使能 */
#define CONFIG_VIDEO3_ENABLE 		            /* usb后摄像头使能 */
```

注：仅有前摄像头的问题，打开CONFIG_VIDEO0_ENABLE使能前视摄像头，CONFIG_VIDEO3_ENABLE注释，CONFIG_VIDEO1_ENABLE可选择保留
有前视摄像头的情况下，以及DVP后拉摄像头的情况下，CONFIG_VIDEO3_ENABLE注释，其他两个开启
有前视摄像头的情况下，以及usb后拉摄像头的情况下，CONFIG_VIDEO1_ENABLE注释，其他两个开启

### 3.3 WIFI配置及接口说明

#### 3.3.1 WIFI配置说明

```c
/*在board级目录中，根据对应的板级文件配置WIFI*/
WIFI_PLATFORM_DATA_BEGIN(wifi_data)
	.module = RTL8189E,
	.sdio_parm = SDIO_GRP_2 | SDIO_PORT_1 | SDIO_4_BIT_DATA |SDIO_DATA1_IRQ| SDIO_CLOCK_40M,
	.wakeup_port = IO_PORTG_06,
	.cs_port = IO_PORTG_07,
	.power_port = IO_PORTE_03,
WIFI_PLATFORM_DATA_END()

/*同时设备表 REGISTER_DEVICES(device_table) 中存在下述代码并且app_config.h中CONFIG_WIFI_ENABLE务必打开*/
#ifdef CONFIG_WIFI_ENABLE
	{ "wifi",  &wifi_dev_ops, (void *) &wifi_data},
#endif
```

|成员|说明|
|----|----|
|module|选择WIFI模块，同时也要选择相应的库进行链接|
|sdio_parm|配置使用引脚，中断和SDIO速率，具体看sdio_host_init.h说明选择对应配置|
|wakeup_port|唤醒引脚|
|cs_port|片选引脚|
|power_port|电源引脚|

#### 3.3.2 ap配置项说明,信道,BGN模式

针对8189WIFI模块:
在ap_config.c中的hostapd_config_file数组，其信息用于配置设备热点
其中：
1、channel=6表示配置为信道6
2、hw_mode=g\n 及ieee80211n=1\n表示ap工作模式为bgn模式
	 hw_mode=g\n 及ieee80211n=0\n表示ap工作模式为bg模式
     hw_mode=b\n 及ieee80211n=0\n表示ap工作模式为b模式
	 
针对8801 WIFI模块:
在uaputl_conf.c 中的uaputl_conf_file数组，其信息用于配置设备热点
    1、channel=1表示配置为信道1
	2、默认配置为BGN模式, 若需要关闭N模式:
	      Enable11n=0 
		  #HTCapInfo=0x111c  
		  #AMPDU=0x03
		  #HT_MCS_MAP=0x000000ff
		  
   3.Rate速率关系:

     1M    2M    5.5M   11M   6M    9M    12M   18M   24M   36M   48M   54M
     0x82,  0x84,  0x8b,  0x96,  0x8C,  0x92,  0x98,  0xA4,  0xB0,  0xC8,  0xE0,  0xEc
	 
	4.配置功率
	TxPowerLevel=24


#### 3.3.3 WIFI模组efuse配置

##### 3.3.3.1 WIFI模组efuse的选择
在rtw_cache.c 中
```c
//返回0就是使用WIFI模组原有的efuse.注释掉return 0；就是使用外部的efuse
char *get_rtw_cache_efuse(void)
{
    return 0;
    return rtw_cache_efuse;
}
```
##### 3.3.3.2 获取WIFI模组内部的efuse
当选择使用WIFI内部efuse时，用户可在set_rtw_cache_efuse函数中，将内部的efuse打印出来，也可在这个函数中修改efuse的内容。
``` 
//如果 get_rtw_cache_efuse 返回0 ,WIFI模组会调用这个函数告诉外部WIFI模组目前的efuse
//用户也可以在此改写buf, 部分修改原有efuse的内容
void set_rtw_cache_efuse(char *buf, unsigned int len)
{
    if (len > sizeof(rtw_cache_efuse)) {
        printf("set_rtw_cache_efuse file size error!!!!, %d ,while1 \r\n", len);
        while (1);
    }
//	put_buf(buf, len);//打印内部efuse的内容示例

//把功率调整到最低，修改内部efuse示例
//    memset(&buf[PATHA_CCK_POWER_IDX_OFFSET], 0x02, PATHA_CCK_POWER_IDX_LEN);
//    memset(&buf[PATHA_BW40_1S_POWER_IDX_OFFSET], 0x02,PATHA_BW40_1S_POWER_IDX_LEN);
}
```
##### 3.3.3.3 通过efuse修改功率
基于原有的值对以下位置进行微调，可调节功率
位于0x10-0x15的位置，共6个字节，设定值范围0-63
位于0x16-0x1A的位置，共5个字节，设定值范围0-63

针对rtl8189模组：
efuse具体每个值的含义，可查阅SDK目录下doc\RTL8189ES_EEPROM_SPEC_R03_20120615.pdf
 
##### 3.3.3.4 通过efuse修改WIFI模组MAC地址
MAC地址位于efuse数组0x11A-0x11F位置
用户可通过修改这六个字节，达到修改MAC地址的目的

针对rtl8189模组：
efuse具体每个值的含义，可查阅SDK目录下doc\RTL8189ES_EEPROM_SPEC_R03_20120615.pdf

注：MAC地址必须符合MAC地址规则，否则设置失败

##### 3.3.3.5 WIFI模组无内部efuse情况处理
1、寻找相同模组，获取其内部efuse
2、将该efuse数组，放置于rtw_cache.c中，替换原本efuse数组
3、根据需要修改WIFI模组功率以及MAC地址

#### 3.3.4 WIFI接口说明
##### 3.3.4.1 接口参数结构体各成员说明
```c
struct cfg_info {
     u32 timeout;
     enum WIFI_MODE mode;
     char *ssid;
     char *pwd;
     char *ap_config_table;
     int (*cb)(void *, enum NETWORK_EVENT, void *);
     void *net_priv;
     char force_default_mode;
     char port_status;
     char tx_pwr_lmt_enable;
     char tx_pwr_by_rate;
     enum wifi_sta_connect_state sta_status;
     struct netdev_ssid_info *sta_ssid_info;
     u32 sta_ssid_num;
     void *__lan_setting_info;
     u32 sta_channel;
     char p2p_role;
 
};
```
|成员|说明|
|----|----|
|timeout|STA连接超时时间设置|
|mode|模式配置AP，STA，SMP|
|ssid|WIFI名字|
|pwd|WIFI密码|
|cb|设置回调|
|net_priv|回调参数|
|force_default_mode|强制写入VM|
|port_status|引脚状态设置|
|tx_pwr_lmt_enable|设置WIFI发送功率限制|
|tx_pwr_by_rate|设置WIFI根据不同datarate打不同power|
|sta_status|STA状态|
|sta_ssid_info|STA扫描到的ssid信息|
|sta_ssid_num|STA扫描到数量|
|__lan_setting_info|设置AP模式下IP地址、网关、以及掩码|
|sta_channel|获取STA连接的通道|
|p2p_role||


##### 3.3.4.2 WIFI接口说明

**打开设备**

    wifi_dev = dev_open("wifi", NULL); 


**IOCTL操作**

|类型                            |说明         |
|---|---|
   | DEV_AP_MODE |设置AP模式|
  |  DEV_STA_MODE|   STA模式,用于连接AP|
  |  DEV_SMP_MODE|   一键配置|
  |  DEV_NET_SCANF| STA模式请求扫描ssid|
  |  DEV_SET_AP_CONFIG||
  |  DEV_GET_MAC|获取MAC地址|
  |  DEV_SET_DEFAULT_MODE|设置默认模式|
  |  DEV_SAVE_DEFAULT_MODE|保存默认配置，到VM区|
  | DEV_CHANGE_SAVING_MODE|改变VM区默认配置|
  |  DEV_SET_CB_FUNC|       设置回调|
  |  DEV_NETWORK_START|启动WIFI模块|
  |  DEV_NETWORK_STOP|关闭WIFI模块|
  |  DEV_SET_WIFI_CS|      设置引脚|
  |  DEV_SET_WIFI_WKUP|    设置引脚|
  |  DEV_SET_WIFI_POWER|   设置引脚|
  |  DEV_STA_STATUS|       获取STA状态|
  |  DEV_GET_DEFAULT_WIFI_INFO|  获取默认的WIFI_INFO(出厂设置的WIFI_INFO)|
  |  DEV_GET_CUR_WIFI_INFO|获取当前WIFI_INFO|
  |  DEV_GET_STA_SSID_INFO|获取扫描到ssid,备注：当STA连接成功时候，调用DEV_GET_STA_SSID_INFO时，先调用DEV_NET_SCANF|
 |DEV_SET_LAN_SETTING|设置无线IP，掩码，网关，DHCP服务器信息|
 |    DEV_SET_WIFI_POWER_SAVE   |设置WIFI低功耗模式,有可能降低距离|
 |DEV_SET_WIFI_TX_PWR_LMT_ENABLE   |设置WIFI发送功率限制   0: Disable, 1: Enable, 2: Depend on efuse|
 |DEV_SET_WIFI_TX_PWR_BY_RATE   |设置WIFI根据不同datarate打不同power     0: Disable, 1: Enable, 2: Depe|nd on ef    use 
 |DEV_GET_WIFI_CHANNEL   |获取当前WIFI连接的路由器的信道,通常在 WIFI_EVENT_STA_CONNECT_SUCC 事件获取得到|
 |DEV_WIFI_PM_SUSPEND  |WIFI进入低功耗模式,停止sdio接收和发送数据,等待AP接入唤醒或者调用PM_RESUME唤醒|
 |DEV_WIFI_PM_RESUME  |退出WIFI低功耗模式,恢复到正常模式|
 |DEV_P2P_MODE      |wifi direct p2p mode|




**参数使用**

|类型                            |设置参数         |返回参数         |
|---|---|---|
|DEV_AP_MODE                     |mode,ssid,pwd    |mode,ssid,pwd    |
|DEV_STA_MODE                    |mode,ssid,pwd    |mode,ssid,pwd    |
|DEV_SMP_MODE                    |未实现           |未实现           |
|DEV_NET_SCANF                   |NULL             |NULL             |
|DEV_SET_AP_CONFIG               |未实现  |未实现  |
|DEV_GET_MAC                     |parm传入char指针 |parm传入char指针 |
|DEV_SET_DEFAULT_MODE            |mode,ssid,pwd    |mode,ssid,pwd    |
|DEV_SAVE_DEFAULT_MODE           |mode,ssid,pwd    |mode,ssid,pwd    |
|DEV_CHANGE_SAVING_MODE          |mode,ssid,pwd    |mode,ssid,pwd    |
|DEV_SET_CB_FUNC                 |cb,net_priv      |cb,net_priv      |
|DEV_NETWORK_START               |NULL             |NULL             |
|DEV_NETWORK_STOP                |NULL             |NULL             |
|DEV_SET_WIFI_CS                 |port_status      |port_status      |
|DEV_SET_WIFI_WKUP               |port_status      |port_status      |
|DEV_SET_WIFI_POWER              |port_status      |port_status      |
|DEV_STA_STATUS                  |      NULL          |sta_status       |
|DEV_GET_DEFAULT_WIFI_INFO       |            NULL     |mode,ssid,pwd    |
|DEV_GET_CUR_WIFI_INFO           |         NULL        |mode,ssid,pwd    |
|DEV_GET_CUR_STA_SSID_INFO       |      NULL           |sta_ssid_info,sta_ssid_num |
|DEV_SET_LAN_SETTING|__lan_setting_info|NULL|
|DEV_SET_WIFI_POWER_SAVE   |NULL|NULL|
|DEV_SET_WIFI_TX_PWR_LMT_ENABLE   |tx_pwr_lmt_enable|NULL|
|DEV_SET_WIFI_TX_PWR_BY_RATE   |tx_pwr_by_rate|NULL|
|DEV_GET_WIFI_CHANNEL   |NULL|sta_channel|
|DEV_WIFI_PM_SUSPEND  |NULL|NULL|
|DEV_WIFI_PM_RESUME  |NULL|NULL|
|DEV_P2P_MODE      |mode|mode|

``` 
static int wifi_ioctl(struct device *device, int cmd, int parm)
device :设备句柄, wifi_dev = dev_open("wifi", NULL);  
cmd    :例如(DEV_AP_MODE)命令
parm   :使用cfg_info结构,设置类的命令填充cfg_info参数如下表,返回类的命令，传入cfg_info结构
return : 0 成功 -1 失败
```
**关闭设备**
``` 
 dev_close(wifi_dev); 
```
##### 3.3.4.3 WIFI接口使用说明

```
WIFI模式配置：
在wifi_app_task.c中network_user_callback中的WIFI_EVENT_MODULE_START进行设置
#if defined (WIFI_CAM_SUFFIX)
        sprintf(ssid, WIFI_CAM_PREFIX WIFI_CAM_SUFFIX);

#else
        dev_ioctl(wifi_dev, DEV_GET_MAC, (u32)&mac_addr);
        sprintf(ssid, WIFI_CAM_PREFIX"%02x%02x%02x%02x%02x%02x"
                , mac_addr[0]
                , mac_addr[1]
                , mac_addr[2]
                , mac_addr[3]
                , mac_addr[4]
                , mac_addr[5]);

#endif
#if 1
        info.ssid = ssid;//热点ssid
        info.pwd = "";//热点pwd
        info.mode = AP_MODE;//WIFI模式
        info.force_default_mode = 1;//强制使用当前配置
       //如果有默认配置使用默认配置，如果没有默认配置则当前信息生效并保存为默认配置，
       //如果 info.force_default_mode = 1，则强制使用当前配置
        dev_ioctl(wifi_dev, DEV_SAVE_DEFAULT_MODE, (u32)&info);
#endif

WIFI_CAM_PREFIX 默认为wifi_camera_ac54_,则ssid默认为wifi_camera_ac54_+MAC地址，ssid可自行定义

切换模式：
在开机默认模式为AP模式，要切换STA模式或P2P模式

eg：
    //切换模式前，需要断开所有客户端，这里仅做示例
    ctp_srv_disconnect_all_cli();
    //填充STA_MODE所要连接的路由器热点名称和密码
    struct cfg_info info;
    info.ssid = ssid;
    info.pwd = pwd;
    info.mode = STA_MODE; // P2P_MODE
    //切换WIFI模式到STA模式,切换成功后设备自行连接上热点
    dev_ioctl(wifi_dev, DEV_STA_MODE, (u32)&info);
    //选择是否保存当前WIFI模式信息
    if (atoi(status)) {
    	info.force_default_mode = 1;
    	dev_ioctl(wifi_dev, DEV_SAVE_DEFAULT_MODE, (u32)&info);
    }

其中DEV_STA_MODE用于切换STA模式，使用DEV_CHANGE_SAVING_MODE可以改写VM区WIIF信息。

开关WIFI：
eg:
void net_app_init(void)
{
    puts("ctp server init\n");
    ctp = server_open("ctp_server", (void *)&server_info);

    if (!ctp) {
        printf("ctp server fail\n");
    }

    puts("http server init\n");
    http_get_server_init(HTTP_PORT); //8080

    preview_init(VIDEO_PREVIEW_PORT, NULL); //2226

    playback_init(VIDEO_PLAYBACK_PORT, NULL);

    puts("ftpd server init\n");
    stupid_ftpd_init("MAXUSERS=2\nUSER=FTPX	12345678	 0:/	  2   A\n", NULL);
}

void net_app_uninit(void)
{
    puts("ctp server init\n");
    server_close(ctp);

    puts("http server init\n");
    http_get_server_uninit(); //8080

    preview_uninit(); //2226

    playback_uninit();

    puts("ftpd server init\n");
    stupid_ftpd_uninit();
}
//启动WIFI
void wifi_on(void)
{
//启动WIFI
    dev_ioctl(wifi_dev, DEV_NETWORK_START, 0);
//初始化网络相关服务
    net_app_init();
}

//关闭WIFI
void wifi_off(void)
{
//卸载网络相关服务
    net_app_uninit();
//关闭WIFI
    dev_ioctl(wifi_dev, DEV_NETWORK_STOP, 0);
}

注：开关WIFI只需分别使用DEV_NETWORK_START和DEV_NETWORK_STOP两命令，
    但需注意：在开WIFI时需初始化net_app_init，关WIFI时需net_app_uninit。
    **开的应用需要相应关闭切记**

```
#### 3.3.5 USB WIFI接口更换使用说明
1、确定liba文件夹存在rtl8188e.a依赖库；
2、主工程codeblock，选择build option选项，选择linker setting的link libraries选项，把rtl8189e.a或者其他wifi库换成rtl8188e.a，顺序不变；
3、打开CONFIG_WIFI_ENABLE宏：app_config.h配置CONFIG_WIFI_ENABLE宏必须打开，版籍的CONFIG_WIFI_ENABLE宏控制分支之下不能注释；
4、版籍：关闭{"usb0", &usb_dev_ops, (void *)&usb0_data}，打开{"usb0", &usbwifi_dev_ops, (void *)&usb0_data}，usb0或者usb1看具体硬件接口；
5、board.c：wifi模组配置.module = RTL8188E,结构体其他成员配置为0；
6、RTL8188EU USB需要配置不在80211n模式运行：具体配置为：ap_config.c 顶部打开#define USE_RTL8188,关闭USE_RTL8189即可。
7、编译下载运行......。
注意：用RTL8188F模块，把相应步骤的RTL8188E换成RTL8188F即可，RTL8188EU/FU USB需要配置不在80211n模式运行；设备启动前确保USB wifi模组已经插上主机USB，确保模组散热效果好！！！
#### 3.3.6 AP模式下修改IP地址
修改wifi_app_task.c中wifi_set_lan_setting_info函数即可达到修改IP地址的目的
``` 
static void wifi_set_lan_setting_info(void)
{
    struct lan_setting lan_setting_info = {

        .WIRELESS_IP_ADDR0  = 192,
        .WIRELESS_IP_ADDR1  = 168,
        .WIRELESS_IP_ADDR2  = 1,
        .WIRELESS_IP_ADDR3  = 1,

        .WIRELESS_NETMASK0  = 255,
        .WIRELESS_NETMASK1  = 255,
        .WIRELESS_NETMASK2  = 255,
        .WIRELESS_NETMASK3  = 0,

        .WIRELESS_GATEWAY0  = 192,
        .WIRELESS_GATEWAY1  = 168,
        .WIRELESS_GATEWAY2  = 1,
        .WIRELESS_GATEWAY3  = 1,

        .SERVER_IPADDR1  = 192,
        .SERVER_IPADDR2  = 168,
        .SERVER_IPADDR3  = 1,
        .SERVER_IPADDR4  = 1,

        .CLIENT_IPADDR1  = 192,
        .CLIENT_IPADDR2  = 168,
        .CLIENT_IPADDR3  = 1,
        .CLIENT_IPADDR4  = 2,

        .SUB_NET_MASK1   = 255,
        .SUB_NET_MASK2   = 255,
        .SUB_NET_MASK3   = 255,
        .SUB_NET_MASK4   = 0,
    };

    struct cfg_info info;
    info.__lan_setting_info = &lan_setting_info;
    dev_ioctl(wifi_dev, DEV_SET_LAN_SETTING, (u32)&info);
}
```

### 3.4 网络相关应用说明

#### 3.4.1 CTP命令使用
所有的命令都在ctp_cmd.c中实现，简单例子设置视频的EXP：
第一步：分别实现PUT操作和GET操作
PUT操作是手机发，设备端处理，其中调用json-c库进行解析，再进行逻辑操作。
GET操作是设备端发，手机处理，其中如果有参数一样调用json-c库进行解析，再进行逻辑操作。
```
int cmd_get_video_exp(void *priv, char *content)
{
    char buf[32];

    int exp = db_select("exp");
    sprintf(buf, "exp:%d", exp);
    CTP_CMD_COMBINED(priv, CTP_NO_ERR, "VIDEO_EXP", "NOTIFY", buf);
    return 0;
}
int cmd_put_video_exp(void *priv, char *content)
{
    json_object *new_obj = NULL;
    json_object *parm = NULL;
    json_object *tmp = NULL;
    char buf[128];

    new_obj = json_tokener_parse(content);
    parm =  json_object_object_get(new_obj, "param");
    tmp =  json_object_object_get(parm, "exp");

    char *tmp_value = json_object_get_string(tmp);
    printf("ctp pro  %s \n", tmp_value);
    db_update("exp", atoi(tmp_value));
    json_object_put(new_obj);
    return 0;
}
```
第二步
在ctp_video_cmd_tab添加实现的GET和PUT操作，还有相应的命令字符串。
```c
const struct ctp_map_entry ctp_video_cmd_tab[] sec(.ctp_video_cmd) = {
    {NULL, "VIDEO_PARAM", cmd_get_video_param, cmd_put_video_param},
    {NULL, "VIDEO_CTRL", cmd_get_video_ctrl, cmd_put_video_ctrl},
    {NULL, "VIDEO_FINISH", NULL, NULL}, //特殊命令，只有回复，用于录像完成
    {"two", "DOUBLE_VIDEO", cmd_get_double_video, cmd_put_double_video},
    {"cyc", "VIDEO_LOOP", cmd_get_video_loop, cmd_put_video_loop},
    {"wdr", "VIDEO_WDR", cmd_get_video_wdr, cmd_put_video_wdr},
    {"exp", "VIDEO_EXP", cmd_get_video_exp, cmd_put_video_exp},
    {"mot", "MOVE_CHECK", cmd_get_video_move_check, cmd_put_video_move_check},
    {"mic", "VIDEO_MIC", cmd_get_video_mic, cmd_put_video_mic},
 .....
```
注：
1.有些没命令没有PUT和GET操作,就是NOTIFY命令
2.命令可以异步回复，比如SD状态，当SD卡插入或拔出，会主动NOTIFY已连接的手机。
3.设备收到命令必须回复APP，一一对应

#### 3.4.2自定义实时流的使用

##### 3.4.2.1  自定义实时流配置说明
在WiFi文件夹中，stream文件夹包含video_rt_xxx.c文件。
一般提供三个函数给库内调用（打开实时流调用）
```c
/*  
*   函数说明:创建或获取socket句柄
*   参数说明:path：路径（例如：rtp://192.168.1.1:5555）mode:通道
*   返回说明:成功：rt_stream_info 指针  失败：-1
*/
struct rt_stream_info *net_rt_vpkg_open(const char *path, const char *mode)


/*  
*   函数说明:发送帧函数,发送到手机APP端的每一音频/视频帧都通过此函数
*   参数说明:buffer:帧指针 len:帧长 type:帧类型（视频  和  音频）
*   返回说明:成功：帧长 失败：-1
*/
int net_rt_send_frame(struct rt_stream_info *info, char *buffer, size_t len, u8 type)


/*  
*   函数说明:关闭socket
*   参数说明:path：路径（例如：rtp://192.168.1.1:5555）mode:通道
*   返回说明:
*/
int net_rt_vpkg_close(struct rt_stream_info *info)


REGISTER_NET_VIDEO_STREAM_SUDDEV(rtp_video_stream_sub) = {
    .name = "rtp",
    .open = net_rt_vpkg_open,
    .write = net_rt_send_frame,
    .close = net_rt_vpkg_close,
};
```




##### 3.4.2.2打开或关闭自定义实时流
```
int cmd_put_open_rt_stream(void *priv, char *content)
 {           
     json_object *new_obj = NULL;    
     json_object *parm = NULL;
     char buf[128];
     u8 mark;
     const char *h, *w, *format, *fps;
     //切换UI
     net_switch_ui("video_rec");
     struct intent it;     
     init_intent(&it);
     it.name = "video_rec";
     //设置参数  
     it.action = ACTION_VIDEO0_OPEN_RT_STREAM; 
     new_obj = json_tokener_parse(content);
     parm =  json_object_object_get(new_obj, "param");
     h = json_object_get_string(json_object_object_get(parm, "h"));
     w = json_object_get_string(json_object_object_get(parm, "w"));
     format = json_object_get_string(json_object_object_get(parm, "format"));
     fps = json_object_get_string(json_object_object_get(parm, "fps"));
             
     mark = 2;//音视频同时打开  0 打开音频 1 打开视频
     struct rt_stream_app_info info; 
     if (w && h) {         
        info.width = atoi(w);
        info.height = atoi(h);
     } else {
        info.width = 1920;
        info.height = 1080;
            
     }       
     info.fps    = atoi(fps);
     info.type   = atoi(format);
     info.priv = priv;     
                           
     it.data = (const char *)&mark;//打开视频
     it.exdata = (u32) &info; //视频参数
                           
     start_app(&it);       
     
     rt_stream_set_sockaddr(ctp_srv_get_cli_addr(priv), VIDEO_FORWARD);
     
 #if APP_PROJECTION        
     wifi_projection_uninit(NULL);   
     dev_req_projection_uninit();    
 #endif      
            
     json_object_put(new_obj);
     return 0;
                           
}           


static int cmd_put_close_rt_stream(void *priv, char *content)
{
    json_object *new_obj = NULL;
    json_object *parm = NULL;
    char buf[128];
    u8 mark;
    const char *status = NULL;
    struct intent it;

    init_intent(&it);
    net_switch_ui("video_rec");
    it.name = "video_rec";
    //设置参数
    it.action = ACTION_VIDEO0_CLOSE_RT_STREAM;
    new_obj = json_tokener_parse(content);
    parm =  json_object_object_get(new_obj, "param");
    status = json_object_get_string(json_object_object_get(parm, "status"));

    if (atoi(status)) {
        mark = 2;//音视频同时关闭  0 关闭音频 1 关闭视频
        it.data = (const char *)&mark; //close video param
        start_app(&it);
        rt_stream_rm_sockaddr(ctp_srv_get_cli_addr(priv), VIDEO_FORWARD);

    }

    json_object_put(new_obj);
    return 0;
}

```
注：
    通过APP端收到的参数进行配置小机实时流，主要是参数有height ，width ，format ， fps四个参数。

##### 3.4.2.3自定义实时流码流设置

```
static int video_rec_get_abr(u32 width)
{
    if (width <= 720) {
       
        return 4000;
    } else if (width <= 1280) {
        return 8000;
    } else if (width <= 1920) {
        return 10000;
    } else {
        return 18000;
    }
}
```
注：
    根据width设置码流，4000对应网络流500KB/s-650KB/s，8000对应网络流800KB/s-1200KB/s，10000对应网络流1800KB/s-2200KB/s。

##### 3.4.2.4自定义实时流网络类型设置
在app_config.h中设置CONFIG_NET_TCP_ENABLE或CONFIG_NET_UDP_ENABLE使用TCP或UDP。



#### 3.4.3 RTSP实时流配置说明

#### 3.4.3.1 RTSP初始化配置
```
struct fenice_config {
    char protocol[4];
    unsigned int port;
    int (*exit)(void);  /* 关闭底层硬件 */
    int (*setup)(void);  /* 开启底层硬件 */
    int (*info)(struct fenice_source_info *info);
};
```

|成员|说明|
|----|----|
|protocol|设置网络类型UDP或TCP|
|port|端口设置默认544|
|exit|关闭底层硬件|
|setup|开启底层硬件|
|info|设置参数 ，height，width rate fps|


##### 3.4.3.2 启用rtsp服务
```
    struct fenice_config conf;
    extern int fenice_video_rec_setup(void);
    extern int fenice_video_rec_exit(void);
    extern int fenice_video_rec_info(struct fenice_source_info * info);
    strncpy(conf.protocol, "UDP", 3);
    conf.exit = fenice_video_rec_exit;
    conf.setup = fenice_video_rec_setup;
    conf.info = fenice_video_rec_info;
    conf.port = RTSP_PORT;  /* 当为0时,用默认端口554 */
    extern int stream_media_server_init(struct fenice_config * conf);
    stream_media_server_init(&conf);

```
##### 3.4.3.3关闭rtsp服务
```
        struct eth_addr *hwaddr = (struct eth_addr *)network_ctx;
#if 1
 //强制断开所有RTSP链接,实际上应该只断开响应客户端
        extern void stream_media_server_close(struct sockaddr_in * dest_addr);
        stream_media_server_close(NULL);
#endif
        printf("WIFI_EVENTdr _AP_ON_DISCONNECTED hwaddr = %02x:%02x:%02x:%02x:%02x:%02x \r\n\r\n",
               hwaddr->addr[0], hwaddr->addr[1], hwaddr->addr[2], hwaddr->addr[3], hwaddr->addr[4], hwaddr->addr[5]);
        ctp_keep_alive_find_dhwaddr_disconnect((struct eth_addr *)hwaddr->addr);
#if 1
        extern void fenice_close_hardware(struct sockaddr_in * dest_addr);
        fenice_close_hardware(0);
#endif
```


##### 3.4.3.4 修改RTSP链接
```
在wifi_app_task.c中，stream_media_server_init(&conf);   之前增加如下代码
#if 0
    extern void rtsp_modify_url(const char *user_custom_name, const char *user_custom_content);
    char *user_custom_name = "rt";
    char *user_custom_content =
        "stream\r\n  \
file_ext_name 264\r\n \
media_source live\r\n  \
priority 1\r\n  \
payload_type 96\r\n  \
clock_rate 90000\r\n  \
encoding_name H264\r\n  \
coding_type frame\r\n  \
byte_per_pckt 1458\r\n  \
stream_end";
    rtsp_modify_url(user_custom_name, user_custom_content);
 #endif
 使用说明：
              1.     上述name配置配置的rtsp链接为rtsp://192.168.1.1/rt
              2.     上述content配置·配置实时流为H264实时流无音频
 content其他可选项说明：
			 1、配置H264实时流，有音频数据      
 char  *content =
    "stream\r\n \
file_ext_name 264\r\n \
media_source live\r\n \
priority 1\r\n \
payload_type 96\r\n \
clock_rate 90000\r\n \
encoding_name H264\r\n \
coding_type frame\r\n \
byte_per_pckt 1458\r\n \
stream_end\r\n \
stream\r\n \
file_ext_name pcm\r\n \
media_source live\r\n \
priority 1\r\n \
payload_type 97\r\n \
encoding_name L16\r\n \
clock_rate 8000\r\n \
stream_end"
           2、配置H264实时流、无音频数据
 char *content =
    "stream\r\n  \
file_ext_name 264\r\n \
media_source live\r\n  \
priority 1\r\n  \
payload_type 96\r\n  \
clock_rate 90000\r\n  \
encoding_name H264\r\n  \
coding_type frame\r\n  \
byte_per_pckt 1458\r\n  \
stream_end"
			3、配置jpeg实时流，有音频数据
 char *content =
    "stream\r\n  \
file_ext_name avi\r\n \
priority 1\r\n  \
payload_type 26\r\n \
clock_rate 90000\r\n    \
encoding_name JPEG\r\n \
coding_type frame\r\n   \
stream_end\r\n   \
stream\r\n \
file_ext_name avi_in_pcm\r\n \
priority 1\r\n  \
payload_type 97\r\n \
clock_rate 8000\r\n \
audio_channels 1\r\n    \
encoding_name L16\r\n   \
bit_per_sample 16\r\n   \
pkt_len 20\r\n  \
stream_end"
		4、配置jpeg实时流，无音频数据
 char *content =
    "stream\r\n  \
file_ext_name avi\r\n \
media_source live\r\n  \
priority 1\r\n  \
payload_type 26\r\n \
clock_rate 90000\r\n    \
encoding_name JPEG\r\n \
coding_type frame\r\n   \
stream_end"

```
##### 3.4.3.5 RTSP分辨率修改
```
1、分辨率数组
static const u16 rec_pix_w[] = {1920, 1280, 640, 384};
static const u16 rec_pix_h[] = {1088, 720,  480, 240};
2、配置视频流参数
int fenice_video_rec_info(struct fenice_source_info *info)
{

    REC_PIX_W = rec_pix_w[2];
    REC_PIX_H = rec_pix_h[2];
    REC_FPS = 0;
    SAMPLE_RATE = 8000;
    CHANNEL_NUM = 1;

//配置分辨率
    info->width = REC_PIX_W;
    info->height = REC_PIX_H;
    //该帧率设置仅用于通知客户端，设置为0即可，对固件端无影响
    info->fps = REC_FPS;

    info->sample_rate = SAMPLE_RATE;
    info->channel_num = CHANNEL_NUM;

    return 0;
}
```
##### 3.4.4.6 RTSP前后视实时流选择
```
1、宏表示含义
    STRM_SOURCE_VIDEO0表示前视实时流，  STRM_SOURCE_VIDEO1表示后视实时流
2、可修改全局变量初始值，选择默认打开的是前视还是后视的实时流
    static int strm_source_type = STRM_SOURCE_VIDEO0;
3、可通过调用fenice_video_type动态设置实时流类型
    void fenice_video_type(int type)
    {
        strm_source_type = type;
    }
```

##### 3.4.4.7 RTSP 输入输出帧统计
```
//编码器每编出一帧会放进队列,并且进入此函数统计, 参数fbuf就是帧指针, frame_size 就是帧大小
void strm_264_pkg_get_in_frame(char *fbuf, u32 frame_size)
{
    __this->fbuf_fcnt += 1;
    __this->fbuf_ffil += frame_size;
}

//RTSP 实时流 每发送完成一帧, 会进入此函数进行统计参数 ,fbuf就是帧指针, frame_size 就是帧大小
void strm_264_pkg_get_out_frame(char *fbuf, u32 frame_size)
{                                               
    __this->fbuf_fcnt -= 1;                     
    __this->fbuf_ffil -= frame_size;            
}                                               

用户可以根据 fbuf_fcnt和fbuf_ffil 统计出当前 RTSP 发送实时流卡顿情况,帧堆积情况,发送数据量的大小情况等;

```


#### 3.4.4 以太网ETH使用说明
##### 3.4.4.1 使能有线以太网
```
app_config.h 打开 #define CONFIG_ETH_PHY_ENABLE

board_x.c 根据PHY型号和修改对应引脚配置:
#ifdef CONFIG_ETH_PHY_ENABLE
NET_PLATFORM_DATA_BEGIN(net_phy_data)
    .name = (u8 *)"rtl8201f",
    .speed = PHY_FULLDUPLEX_100M,
    .mode  = RMII_MODE,
    .irq   = 1,  //-1为查询  0-7 使用中断的优先级
    .check_link_time = 100, //100ms  // 检测网络连接状态时间间隔
    .rmii_bus = {
        .phy_addr = 0x1,
        .clk_pin = IO_PORTE_02,
        .dat_pin = IO_PORTE_03,
    },
NET_PLATFORM_DATA_END()
#endif

有线以太网ETH 初始化会在 wire_app_task.c的net_task函数进行, 用户可以在这里配置MAC地址和初始化网络socket应用程序,
eth_state_cb函数用于指示以太网口网线插拔状态,
如果同时存在WIFI和以太网的情况下,由于双网卡的情况, 网络socket编程需要使用函数 Get_IPAddress 绑定对应网卡的IP地址,防止网络数据在两个网卡乱窜.

```

#### 3.4.5 WiFi一键配置/Smartlink 使用方法
```
使用
info.mode = SMP_CFG_MODE;               
dev_ioctl(wifi_dev, DEV_SMP_MODE, (u32)&info);
使WIFI进入一键配置模式;
当接收到手机端发送的SSID和密码信息, 程序会进入wifi_smp_connect_task,然后自动连接路由器.

```


#### 3.4.6 获取WIFI当前上下行速率
```
调用 wifi_get_upload_rate()获取WIFI底层上行速率, 单位: Byte/每秒;
调用 wifi_get_download_rate()获取WIFI底层上行速率, 单位: Byte/每秒;

```

#### 3.4.7 获取WIFI作为STA模式的时候接收信号强度
```
在WIFI作为STA模式的时候, 调用 get_rx_signal(), 单位: 0-100;

```

#### 3.4.8 WIFI网络事件状态监测通知
```
位于 network_user_callback 函数

case WIFI_EVENT_MODULE_INIT:
WIFI模块初始化之前会进入此分支, 例如打开WIFI电源;

case WIFI_EVENT_MODULE_START:
WIFI模块初始化成功之后会进入此分支,例如用于设定WIFI启动后的默认模式(AP/STA等)

case WIFI_EVENT_MODULE_START_ERR:
WIFI模块初始化失败会进入此分支, 一般为硬件初始化失败

case WIFI_EVENT_AP_START:
AP模式启动完成会进去此分支

case WIFI_EVENT_AP_STOP:
AP模式停止会进入此分支

case WIFI_EVENT_STA_START:
STA模式启动完成会进去此分支

case WIFI_EVENT_AP_STOP:
STA模式停止会进入此分支

case WIFI_EVENT_STA_DISCONNECT:
STA模式下,WIFI断开;

case WIFI_EVENT_STA_SCAN_COMPLETED:
如果外部调用 DEV_NET_SCANF 请求WIFI扫描, 扫描完成后会异步进入此分支, 然后可以使用 DEV_GET_STA_SSID_INFO 获取扫描到的SSID列表信息;

case WIFI_EVENT_STA_CONNECT_SUCC:
STA模式连接成功会进入此分支;

case WIFI_EVENT_STA_NETWORK_STACK_DHCP_SUCC:
STA模式连接成功并且分配得到IP地址成功;

case WIFI_EVENT_STA_CONNECT_TIMEOUT_NOT_FOUND_SSID:
STA模式,WIFI找不到想要连接的SSID

case WIFI_EVENT_STA_CONNECT_TIMEOUT_ASSOCIAT_FAIL:
STA模式, WIFI连接不上对应的SSID, 通常是密码不正确;

case WIFI_EVENT_SMP_CFG_COMPLETED:
WIFI 一键配置 成功后会进入此分支,然后得到SSID和密码,转为STA模式去连接对应的SSID;

case WIFI_EVENT_SMP_CFG_TIMEOUT:
WIFI 一键配置 超时后会进入此分支,但是配置还是继续进行的,超时时间可以通过 DEV_SET_SMP_CONFIG_TIMEOUT_SEC 配置

case WIFI_EVENT_AP_ON_ASSOC:
AP模式下, 有客户端连接上会进入此分支,可以获取出是哪个MAC地址连接上来的;

case WIFI_EVENT_AP_ON_DISCONNECTED:
AP模式下, 有客户端断开会进入此分支,可以获取出是哪个MAC地址断开的;

```

#### 3.4.9 WIFI在AP模式下的空闲状态时自动进入低功耗模式
```
	在wifi_app_task.c文件中，通过定义宏AP_AUTO_SUSPEND_TIMEOUT设置AP模式下从空闲状态（没有其它station连接此AP）到进入低功耗模式的等待时间，单位为毫秒，即可使能该功能。
    在低功耗模式下，如果有其它设备请求接入或者通过调用dev_ioctl手动唤醒，AP将退出低功耗模式，恢复到正常模式。
    屏蔽宏AP_AUTO_SUSPEND_TIMEOUT即可关闭该功能。
    注意：当从AP切换到STA等其它模式时会自动退出低功耗模式，不需要手动唤醒。
```

#### 3.4.10 WIFI MP测试,定频测试
```
第一步：在wifi_app_task.c中的network_user_callback中，配置WIFI为MP_TEST_MODE模式
	info.mode = MP_TEST_MODE;                              
	info.force_default_mode = 1;
	dev_ioctl(wifi_dev, DEV_SAVE_DEFAULT_MODE, (u32)&info);
第二步：在对应的板级文件中增加函数，函数功能为返回所期望使用的串口设备的设备名
void mp_test_set_uart(char **uart_name)
{
    if (uart_name) {
        *uart_name = "uart1";//跟进当前串口选择
    }
}
第三步：配置所期望使用的串口设备，具体可参考3.5章节 串口设备配置说明

第四步：当设备配置并且启动完成,接好串口线到电脑，注意串口与设备共地问题
对于瑞昱8189模块：
使用 WIFI_MP_TEST_TOOL目录下的FCCStruct.exe;
对于marvell 8801 使用WIFI_MP_TEST_TOOL目录下的DutApiWiFi8801BrdigeUart.exe;
更具体的说明请看<WIFI_MP_TEST_TOOL工具说明>

```
### 3.5 串口设备配置说明
以串口1为例子
```
第一步：确认设备列表中包含有uart1
设备列表位于对应的板级文件
REGISTER_DEVICES(device_table) = { 
 	{"uart1",&uart_dev_ops,&uart1_data},  
}
第二步：配置uart1_data结构体
位于对应的板级文件
static void  uart_port_remap_func(void)
{
	IOMC2 &= ~( BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2) | BIT(1) | BIT(0) );
	IOMC2 |=  ( BIT(4) | BIT(1) | BIT(0) );
    gpio_direction_input(IO_PORTB_03);
	IOMC3 &= ~( BIT(24) | BIT(23) | BIT(22));
	IOMC3 |= BIT(24);

	IOMC1 &= ~(0xf << 8);//使用output_channel0,选择信号来自串口3
    IOMC1 |=    (0x3 << 8);
    gpio_direction_output(IO_PORTA_08, 0);//重定向脚为IO_PORTA_08
    gpio_set_pull_up(IO_PORTA_08, 1);
    gpio_set_pull_down(IO_PORTA_08, 1);
    gpio_set_die(IO_PORTA_08, 0);

}
UART1_PLATFORM_DATA_BEGIN(uart1_data)
	//串口波特率
	.baudrate = 115200,
	//PORTC_2_3、PORTH_2_5、PORTH_14_15、PORTC_6_7、PORT_REMAP
	//PORTC_2_3表示发送脚为PC2,接收脚为PC3，PORT_REMAP表示使用串口引脚重映射
	.port = PORT_REMAP,
	//如果使能串口重映射，该函数将被调用
	.port_remap_func = uart_port_remap_func,
    //以下配置采用默认配置即可
	.max_continue_recv_cnt = 1024,
	.idle_sys_clk_cnt = 100000,
    .clk_src = PLL_48M,
UART1_PLATFORM_DATA_END()
#endif
第三步、串口的初始化和收发示例程序
static void *uart_dev_handle;
void spec_uart_init(void)
{
    //设置接收buf，可根据需要扩大
    static char uart_circlebuf[1 * 1024] __attribute__((aligned(32))); //串口循环数据buf,根据需要设置大小

    int parm;
	//打开设备，这里uart1对应设备列表的uart1
    uart_dev_handle = dev_open("uart1", 0);
    //传递接收buf的地址
    dev_ioctl(uart_dev_handle, UART_SET_CIRCULAR_BUFF_ADDR, (int)uart_circlebuf);
    //传递接收buf的大小
	parm = sizeof(uart_circlebuf);
    dev_ioctl(uart_dev_handle, UART_SET_CIRCULAR_BUFF_LENTH, (int)&parm);
// 是否设置为 接收完指定长度数据, spec_uart_recv才出来
#if 0 
    parm = 1;
    dev_ioctl(uart_dev_handle, UART_SET_RECV_ALL, (int)&parm);
#endif
// 是否设置为阻塞方式读
#if 1 
    parm = 1;
    dev_ioctl(uart_dev_handle, UART_SET_RECV_BLOCK, (int)&parm);
#endif
//使能串口1
    dev_ioctl(uart_dev_handle, UART_START, (int)0);
//开启下面的代码，可简单测试串口收发是否正常
#if 0
    int spec_uart_recv(char *buf, u32 len);
    int spec_uart_send(char *buf, u32 len);
    char buf[200];
    int len;
    while (1) {
        len = spec_uart_recv(buf, 200);
        os_time_dly(1);
        spec_uart_send(buf, len);
        os_time_dly(1);
    }
#endif
}
int spec_uart_recv(char *buf, u32 len)
{
    return dev_read(uart_dev_handle, buf, len);
}

int spec_uart_send(char *buf, u32 len)
{
    return dev_write(uart_dev_handle, buf, len);
}
注：该示例程序位于spec_uart.c
```


## 4 其他功能说明
### 4.1 获取YUV数据说明
```
相关代码位于get_image_data.c中
1、初始化获取YUV数据任务，并传递处理YUV数据的回调函数
   void get_yuv_init(void (*cb)(u8 *data))
   函数功能:初始化获取YUV数据任务，并将数据传递给回调函数处理
   参数说明:处理YUV数据的函数

```
### 4.2 动态帧率及码率控制说明

动态帧率及码率控制适用于使用tcp来传输实时流数据，不适用于使用UDP传输实时流的情况，最低支持1/256帧，即每隔256秒，才递交一帧。
#### 4.2.1 API以及参数说明
1、动态帧率以及动态码率控制初始化API
``` 
static void net_fps_fps_bitrate_ctrl_init(void)
{
    //帧率等于分子除以分母，即__this_net->dy_fr/__this_net->dy_fr_denom
    __this_net->dy_fr = NET_VIDEO_REC_FPS0 * 256;//256不允许更改
    __this_net->dy_fr_denom = 256;//256不允许更改
	//网络底层缓存统计
    __this_net->fbuf_fcnt = __this_net->fbuf_ffil = 0;
    //帧率控制初始化
	fps_ctrl_init(&__this_net->fps_ctrl_hdl, NET_VIDEO_REC_FPS0 * 256, 12, 3, 1, NET_VIDEO_REC_FPS0 * 256);
    video_rec0_set_fr(__this_net->dy_fr, __this_net->dy_fr_denom);
     //码率控制初始化
    __this_net->dy_bitrate = video_rec_get_abr(__this_net->net_videoreq[0].rec.width);
    bitrate_ctrl_init(&__this_net->bitrate_ctrl_hdl, __this_net->dy_bitrate, 12, 3, 1024, __this_net->dy_bitrate);
}
```
2、设定帧率API
``` 
static void video_rec0_set_fr(int fr_a, int fr_b)
{
    union video_req req = {0};

    struct drop_fps targe_fps;

    targe_fps.fps_a = fr_a;
    targe_fps.fps_b = fr_b;
    req.rec.targe_fps = &targe_fps;

    req.rec.channel = 1;
    req.rec.state 	= VIDEO_STATE_SET_DR;

    server_request(__this_net->net_video_rec, VIDEO_REQ_REC, &req);

    /*printf("video_rec0_set_frame_rate = %d \r\n", fr);*/
}
```
3、设定码率API
``` 
static void video_rec0_set_bitrate(unsigned int bits_rate)
{
    union video_req req = {0};

    req.rec.channel = 1;

    req.rec.state = VIDEO_STATE_RESET_BITS_RATE;
    req.rec.abr_kbps = bits_rate;

    server_request(__this_net->net_video_rec, VIDEO_REQ_REC, &req);
}
```
4、动态调整相关API

``` 
static void net_video_fps_bitrate_ctrl(void)
{
   
    int fps, fps_denom, bitrate;
    fps_ctrl_update(&__this_net->fps_ctrl_hdl, __this_net->fbuf_fcnt, &fps, &fps_denom);
    bitrate_ctrl_update(&__this_net->bitrate_ctrl_hdl, __this_net->fbuf_fcnt, &bitrate);
     
    if (fps != __this_net->dy_fr || fps_denom != __this_net->dy_fr_denom || bitrate != __this_net->dy_bitrate) {
        __this_net->dy_fr = fps;
        __this_net->dy_fr_denom = fps_denom;
        __this_net->dy_bitrate = bitrate;
        video_rec0_set_fr(fps, fps_denom);
        video_rec0_set_bitrate(bitrate);
        printf("^*^nfcnt= %d, fps= %d[%d/%d], bitrate = %d \r\n", __this_net->fbuf_fcnt,
               fps / fps_denom, fps, fps_denom, bitrate);
    }
}

static void net_video_timer_hdl(void *parm)
{
    static int timer_cnt;
    ++timer_cnt;

    if ((timer_cnt % 1) == 0) {
       net_video_fps_bitrate_ctrl();
    }
}
``` 
5、主要函数参数说明
``` 
动态帧率控制初始化函数
int fps_ctrl_init(fps_ctrl_t *h,int init_fps,int high_th,int low_th,int min_fps,int max_fps)
fps_ctrl_t *h：帧率控制结构体指针
int init_fps   ：初始化帧率  eg：NET_VIDEO_REC_FPS0 * 256
int high_th   ：上阀值，当网络底层缓存帧数超过上阀值时，降低帧率  eg：12
int low_th    ：下阀值，当网络底层缓存帧数小于下阀值时，提高帧率  eg ：3
int min_fps  ：帧率调节所能达到的最小帧率，eg：(n * 256) / 256)   表示 n/256帧
int max_fps ：帧率调节所能达到的最大帧率eg：NET_VIDEO_REC_FPS0 * 256

动态码率控制初始化函数
int bitrate_ctrl_init(bitrate_ctrl_t *h,int init_bitrate,int high_th,int low_th,int min_bitrate, int max_bitrate)
bitrate_ctrl_t *h：码率控制结构体指针
int init_bitrate   ：初始化码率eg：__this_net->dy_bitrate = video_rec_get_abr(__this_net->net_videoreq[0].rec.width); 
int high_th        ：上阀值，当网络底层缓存帧数超过上阀值时，降低码率  eg：12
int low_th         ：下阀值，当网络底层缓存帧数小于下阀值时，提高码率  eg ：3
int min_bitrate  ：码率调节所能达到的最小码率 eg：1024，最低为1024
int max_bitrate ：码率调节所能达到的最大码率，一般设定为与初始化码率相同
```
#### 4.2.2 动态帧率及码率控制启动说明
1、自定义实时流
```
在video_rec.c中NET_VIDEO_REC_FPS0宏表示帧率，该值需小于或等于摄像头帧率，建议值为25
eg：#define  NET_VIDEO_REC_FPS0   25，
在video_rec.c中net_video_rec0_start函数中打开以下代码的注释

net_fps_fps_bitrate_ctrl_init();//动态帧率码率控制初始化
//启动动态帧率码率控制
if (__this_net->timer_handler == 0) {
 __this_net->timer_handler = sys_timer_add(NULL, net_video_timer_hdl, 200);
}
```
2、RTSP实时流
``` 
在net_video_rec.c中STRM_VIDEO_REC_FPS0 宏表示帧率，该值需小于或等于摄像头帧率，建议值为25
eg：#define STRM_VIDEO_REC_FPS0    25，
在net_video_rec.c中fv_video_rec_start函数中打开以下代码的注释
在video_rec.c中net_video_rec0_start

net_fps_fps_bitrate_ctrl_init();//动态帧率码率控制初始化
//启动动态帧率码率控制
if (__this_net->timer_handler == 0) {
 __this_net->timer_handler = sys_timer_add(NULL, net_video_timer_hdl, 200);
}
```
		  
注：即使不启动帧率及码率控制功能，也建议进行初始化
#### 4.2.3 常见问题及解决方法
1、动态帧率及码率控制不生效问题
第一步：确认启动步骤是否正确，具体参考动态帧率及码率控制启动说明
第二步：确认实时流网络类型是否为TCP
如果是自定义实时流，需要确认app_config.h中网络类型的宏为如下配置，并且需要确认                        cpu\AC54xx\tools\res\dev_desc.txt中"net_type": "0"
#define CONFIG_NET_TCP_ENABLE 
//#define CONFIG_NET_UDP_ENABLE
如果是RTSP实时流，需要确认wifi_app_task.c中 struct fenice_config conf;的conf.protocol为"TCP"       

#### 4.2.4 UVC USB设备获取描述符接口
1、头文件
```
#include "usb.h"
#include "device.h"
```
2、获取id
```
/*1 . 获取id:vendor product*/
void uvc_get_id(void)
{
	struct usb_device_id usb_id;
	void *hdl = dev_open("uvc",0);
	if(!hdl)
		return ;
	dev_ioctl(hdl,USBIOC_GET_DEVICE_ID，(u32)&usb_id);
	printf("usb_id->vendor = 0x%X \n\n",usb_id->vendor);
	printf("usb_id->product = 0x%X \n\n",usb_id->product);
	dev_close(hdl);
}
```
2、获取MANUFACTURER
```
/*2 . 获取MANUFACTURER*/
void uvc_get_manufacturer(void)
{
	struct usb_string usb_string;
	void *hdl = dev_open("uvc",0);
	if(!hdl)
		return ;
	dev_ioctl(hdl,USBIOC_GET_MANUFACTURER，(u32)&usb_string);
	printf("usb_string->code_type = 0x%X \n\n",usb_string->code_type);
	printf("usb_string->language = 0x%X \n\n",usb_string->language);
	printf("usb_string->len = 0x%X \n\n",usb_string->len);
	put_buf(usb_string->string,sizeof(usb_string->string));
	dev_close(hdl);
}
```
3、获取PRODUCT
```
/*3 . 获取PRODUCT*/
void uvc_get_product(void)
{
	struct usb_string usb_string;
	void *hdl = dev_open("uvc",0);
	if(!hdl)
		return ;
	dev_ioctl(hdl,USBIOC_GET_PRODUCT_NAME，(u32)&usb_string);
	printf("usb_string->code_type = 0x%X \n\n",usb_string->code_type);
	printf("usb_string->language = 0x%X \n\n",usb_string->language);
	printf("usb_string->len = 0x%X \n\n",usb_string->len);
	put_buf(usb_string->string,sizeof(usb_string->string));
	dev_close(hdl);
}
```


### 4.3 回声消除
```
1、在app_config.h 打开宏 ECHO_CANCELL_ENABLE
2.在 app\echo_cancell.c中echo_cancell_init 调试相关参数

```

## 5 其他问题处理方法
### 5.1 上电不开机，打印battery on first time or mid reset , power off
解决方法：如不需要该功能，可选择注释掉power_ctrl.c中下述代码段
```
if (!usb_is_charging()) {//第一次接电池上电不开机,仅接电池中途复位不开机
puts("battery on first time or mid reset , power off\n");
system_shutdown(0);
}

```
### 5.2  spec_uart收发不正常，串口一直收到FF的数据
问题原因：有可能是由于供地引起的问题
排查方法：使用电源适配器供电，串口供地，确认该问题是否依然存在













